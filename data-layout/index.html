<html>
  <head>
    <title>Data Layout</title>
    <meta name="viewport" content="width=700">
    <meta charset="UTF-8"> 
    <link href="https://fonts.googleapis.com/css?family=Merriweather|Open+Sans" rel="stylesheet">
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <link rel="stylesheet" href="../style.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body><header class="page-heading"><h1><a href="#">Data Layout</h1><a class="home-link" href="../">ullage</a></header><p>For the initial version of the language we just need <code>Bool</code>, <code>Number</code>
and <code>String</code> to have defined layout. It is probably worth thinking
about the future structure of arrays, tuples, and structs though.</p>
<h2 id="Value-and-Reference-Semantics"><a href="#Value-and-Reference-Semantics">Value and Reference Semantics</a></h2><p>The plan is that <code>Bool</code>, <code>Number</code>, and <code>String</code> will all have value
semantics. That is a modification of a <code>String</code> value in one place
will not affect its appearence in another. Such behaviour is referred
to as &quot;value semantics&quot;. This is similar to <code>Copy</code> types in rust and
<code>struct</code> types in C#. I feel that tuple types should also have value
semantics. Similar to <code>ValueTuple</code> in C#.</p>
<p>Array and structure types instead will have reference semantics. This
means that passing a structure to a <code>fn</code> will allow the function to
modify the structure value. This is similar to reference types in C#
and <code>&amp;mut</code> reference in Rust.</p>
<h2 id="Type-Layouts"><a href="#Type-Layouts">Type Layouts</a></h2><p>For the primitive types we have the following type layouts from
language type to LLVM type:</p>
<ul>
<li><code>Bool</code> -&gt; <code>i1</code></li>
<li><code>Number</code> -&gt; <code>i64</code></li>
</ul>
<p>String types are represented as a pair of length, data:</p>
<ul>
<li><code>String</code> -&gt; <code>&lt;{u32,[0 x u8]}&gt;*</code></li>
</ul>
<p>The value of the string is encoded directly as part of the
pair. Allocation of a string uses a variable length array to contain a
sequence of utf-8 characters. There are a few problems with this:</p>
<ul>
<li>The expectation is that strings are rarely modified and we could
probably share a single buffer between string instances and use
reference counting to control mutable access.</li>
<li>This needs some knowledge of when a value is 'dropped' to free the
correct amount of memory.</li>
</ul>
<p>Given these concerns we could lay a string out as:</p>
<ul>
<li><code>String</code> -&gt; <code>&lt;{u32, u32, [0 x u8]}&gt;*</code></li>
</ul>
<p>In this representation each string has a pointer to a reference
counted backing buffer. This should reduce copy-size of each string
and means that a string reference would again have a single easily
known size. We still need to know when the reference should be
deallocated however.</p>
<h2 id="Garbage-Collection"><a href="#Garbage-Collection">Garbage Collection</a></h2><p>Rather than aiming to control access to data as Rust does the language
should provide a garbage collection mechanism to clean up data once no
one references it. There are a few alternatives for this:</p>
<ul>
<li>Don't deallocate - Probably useful to get us off the ground</li>
<li>Reference counting. E.g. Swift's ARC &amp; Python.</li>
<li>Simple mark &amp; sweep GC.</li>
</ul>
<p>For a full mark and sweep or other collector the code generated needs
to insert GC statepoints. For this reason i'm tempted to head towards
the second option. I place of statepoints we will need to decide in
the lower pass where to insert RC retain and release code to maintain
the count. Could this work the same way as Rust's ARC model? In that
case the code just needs to know a fixed point in the scope where each
value is deallocated.</p>
<footer></footer></body></html>