<html>
  <head>
    <title>Parsing and Syntax Trees</title>
    <meta name="viewport" content="width=700">
    <meta charset="UTF-8"> 
    <link href="https://fonts.googleapis.com/css?family=Merriweather|Open+Sans" rel="stylesheet">
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <link rel="stylesheet" href="../style.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body><header class="page-heading"><h1><a href="#">Parsing and Syntax Trees</h1><a class="home-link" href="../">ullage</a></header><p>The parser takes an input <code>SourceText</code> and produces a full-fidelity
<code>SyntaxTree</code>. In theory each character in the source exists as a
<code>Token</code> or <code>TriviaToken</code> within this tree. This initial tree is
intended to provide as rich a possible model of the underlying source
text to allow for syntax transformations in the future. It is later
transformed into an abstract representation of the semantics of the
code by the <code>sem</code> module.</p>
<p><ol><li><a href="#Structure">Structure</a><ol><li><a href="#Structure">Structure</a></li><li><a href="#Diagnostics">Diagnostics</a></li></ol></li></ol></p>
<h2 id="Structure"><a href="#Structure">Structure</a></h2><p>Source is represented by a <code>SourceText</code> type. This exposes characters
as <code>&amp;str</code> slices or via the <code>walk_chars</code> method for tokenisation. The
source text also contains line information and has the ability to take
a position and convert it into a line, column pair.</p>
<p>Parsing creates a lexer which implements token iteration for a given
<code>SourceText</code>. Each token has a <code>Span</code> and <code>TokenKind</code>. Consumption of
tokens from the iterator by <code>Parser::expect</code> stubs out missing tokens
as well as recording errors in a collection of <code>Diagnostic</code>s.</p>
<p>Rather than returning a <code>Result</code> type from the parser instead a valid
<code>SyntaxTree</code> is always be returned. It is the client's responsibility
to inspect the tree for a given parse for diagnostics and act
accordingly. This allows clients to parse malformed source text and
should allow the compiler to produce more error information in each
pass.</p>
<h3 id="Structure"><a href="#Structure">Structure</a></h3><p>The structure looks something like this:</p>
<ul>
<li><code>syntax/parse/</code> - Parser and tokenisation logic</li>
<li><code>syntax/tree/</code> - Tree node types.</li>
<li><code>syntax/text/</code> - Source buffer abstraction.</li>
<li><code>diag.rs</code> - Diagnostic implementation.</li>
</ul>
<h3 id="Diagnostics"><a href="#Diagnostics">Diagnostics</a></h3><p>At the moment diagnostics are just string values and position
information. More metadata can be added later. It might be useful to
add 'level' information to each diagnostic to allow for warnings.</p>
<p>It would be nice to have some kind of diagnostic pretty printing
rather than relying on the <code>main</code> method to walk the diagnostics and
write them to stderr manually.</p>
<footer></footer></body></html>