<html>
  <head>
    <title>Syntax &amp; Grammar</title>
    <meta name="viewport" content="width=700">
    <link href="https://fonts.googleapis.com/css?family=Merriweather|Open+Sans" rel="stylesheet">
    <link rel="stylesheet"
      href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css">
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    <link rel="stylesheet" href="../style.css">
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body><header class="page-heading"><h1><a href="#">Syntax &amp; Grammar</h1><a class="home-link" href="../">ullage</a></header><p>Ullage files are plain-old UTF-8. The language itself is built mainly around <em>words</em> rather than fancy sigils; more reminiscent of Ruby than C and friends.</p>
<p><ol><li><a href="#Tokens">Tokens</a><ol><li><a href="#Words">Words</a></li><li><a href="#Punctuation">Punctuation</a></li><li><a href="#Literals">Literals</a></li><li><a href="#Whitespace">Whitespace</a></li></ol></li><li><a href="#Types">Types</a><ol><li><a href="#Bool"><code>Bool</code></a></li><li><a href="#Number"><code>Number</code></a></li><li><a href="#String"><code>String</code></a></li><li><a href="#Arrays">Arrays</a></li><li><a href="#Tuples">Tuples</a></li></ol></li><li><a href="#Variables">Variables</a><ol></ol></li><li><a href="#Operators">Operators</a><ol></ol></li><li><a href="#Compound-Expressions">Compound Expressions</a><ol><li><a href="#While-loop">While loop</a></li><li><a href="#Print-Expression">Print Expression</a></li><li><a href="#Ternary-Conditional-Expression">Ternary Conditional Expression</a></li><li><a href="#Function-Expression">Function Expression</a></li><li><a href="#Index-Expressions">Index Expressions</a></li><li><a href="#Call-Expression">Call Expression</a></li></ol></li></ol></p>
<h2 id="Tokens"><a href="#Tokens">Tokens</a></h2><p>Source text is treated as one of four basic token types: <em>words</em>, <em>punctuation</em>, <em>literals</em> and <em>whitespace</em>. Words and whitespace are unicode-aware.</p>
<h3 id="Words"><a href="#Words">Words</a></h3><p>Word tokens start with an alphabetic character or an underscore. They may then contain any number of alphanumeric or underscore characters.</p>
<p>Examples of words are: <code>foo</code>, <code>fn</code>, <code>_1</code> and <code>âˆ‚</code>. Some words have special meanings in the grammar:</p>
<pre><code>if unless else while until end fn var let print
</code></pre>
<h3 id="Punctuation"><a href="#Punctuation">Punctuation</a></h3><p>Punctuation characters, such as <code>-</code> and <code>!=</code> are used to represent operators in the language. Currently a handful of punctuation characters are recognised: <code>=</code>, <code>==</code>, <code>!</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>(</code>, <code>)</code>, <code>[</code>, <code>]</code>, <code>,</code>, <code>:</code>, <code>&lt;</code>, and <code>&gt;</code>.</p>
<h3 id="Literals"><a href="#Literals">Literals</a></h3><p>Literals are used to represent constant input values to the program. Literals can be used to specify values of any primitive type (<code>Number</code>, <code>Bool</code> and <code>String</code> so far). Numeric literals consist of one or more consecutive digits: <code>0</code>, <code>42</code>, <code>1337</code>. Although <code>-47</code> evaluates to a negative number the <code>-</code> isn't part of the literal; in fact it is an operator.</p>
<h3 id="Whitespace"><a href="#Whitespace">Whitespace</a></h3><p>Whitespace tokens are made up of one or more <em>space</em> characters. These <em>space</em> characters are either Unicode whitespace, such as tabs &amp; spaces, or comments. Comments are introduced with a <code>#</code> and continue to the end of the line.</p>
<pre><code># This is a comment!
</code></pre>
<h2 id="Types"><a href="#Types">Types</a></h2><p>There are three main base types: <code>Number</code>, <code>String</code> and <code>Bool</code>. These can be extended by creating arrays and tuples.</p>
<h3 id="Bool"><a href="#Bool"><code>Bool</code></a></h3><p>A boolean holds a single bit of information. Boolean values can be created wit the literals <code>true</code> and <code>false</code>; or as the result of a comparison (<code>foo == 100</code>).</p>
<h3 id="Number"><a href="#Number"><code>Number</code></a></h3><p>Number values hold whole numbers, or integers. Currently only decimal numeric literals are supported. All number values are stored in a 64 bit integer value.</p>
<h3 id="String"><a href="#String"><code>String</code></a></h3><p>String literals define a sequence of unicode code points. All strings in the language are UTF-8.</p>
<pre><code>'I am a string'
</code></pre>
<h3 id="Arrays"><a href="#Arrays">Arrays</a></h3><p>An array type is declared by wrapping an existing type in <code>[]</code>. For example <code>[Number]</code> is the type for an array of <code>Number</code> values. To create a new array an array literal can be used:</p>
<pre><code>[1, 2, 3, 4]
</code></pre>
<p>All the values in an array must be of a single type.</p>
<h3 id="Tuples"><a href="#Tuples">Tuples</a></h3><p>Tuples are similar to arrays but can contain values with different types. Tuples are defined by wrapping a comma-separated list of types in <code>()</code>. For example the type <code>(Number, Bool)</code> defines a two-element tuple with the first element a <code>Number</code> and the second a <code>Bool</code>. Instances of a tuple can be created by wrapping values in <code>()</code>:</p>
<pre><code>(100, false)
</code></pre>
<h2 id="Variables"><a href="#Variables">Variables</a></h2><p>Variables are introduced with the <code>var</code> keyword followed by an identifier and an optional type. Immutable variables can be introduced with the <code>let</code> keyword.</p>
<pre><code>let foo = 100
var bar: Number = 10
</code></pre>
<h2 id="Operators"><a href="#Operators">Operators</a></h2><p>Ullage has both infix and prefix operators. Operators are grouped by precedence. Precedence can be overridden or enforced with parentheses.</p>
<p>The following infix operators exist, in precedence order from lowest to highest:</p>
<ul>
<li><code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&gt;</code> - Comparison operators</li>
<li><code>+</code>, <code>-</code> - Addition and Subtraction</li>
<li><code>*</code>, <code>/</code> - Multiplication and division</li>
</ul>
<p>The following infix operators exist. All prefix operators bind directly to the next expression:</p>
<ul>
<li><code>-</code>, <code>+</code>, <code>!</code></li>
</ul>
<h2 id="Compound-Expressions"><a href="#Compound-Expressions">Compound Expressions</a></h2><p>As well as just simple expressions Ullage supports compound ones too. There aren't that many at this time:</p>
<h3 id="While-loop"><a href="#While-loop">While loop</a></h3><p>A basic while loop has the form:</p>
<pre><code>while foo
   do_stuff()
   ..
end
</code></pre>
<p>This continues until the expression <code>foo</code> is false.</p>
<p>There is also an alternate form, the <code>until</code> loop which continues until the expression is true:</p>
<pre><code>until bar
   do_other_stuff()
end
</code></pre>
<h3 id="Print-Expression"><a href="#Print-Expression">Print Expression</a></h3><p>The <code>print</code> word acts as a prefix operator. It will print the expression immediately to the right of it to standard output and return the value.</p>
<pre><code>print 'hello world'
</code></pre>
<h3 id="Ternary-Conditional-Expression"><a href="#Ternary-Conditional-Expression">Ternary Conditional Expression</a></h3><p>The ternary expression in Ullage has two forms: <code>if</code> and <code>ulesss</code>.</p>
<pre><code>foo if bar else baz
</code></pre>
<p>will evaluate the expression on the left hand side if the condition <code>bar</code> is true, or the right hand size <code>baz</code> if false.</p>
<p>The <code>unless</code> expression does the opposite:</p>
<pre><code>biff unless bop else buzz
</code></pre>
<h3 id="Function-Expression"><a href="#Function-Expression">Function Expression</a></h3><p>Finally an <code>fn</code> expression can be used to introduce a function:</p>
<pre><code>fn mod(n: Number, d: Number): Number
   n if n &lt; d else mod(n - d, d)
end
</code></pre>
<p>This defines a function named <code>mod</code> which takes two <code>Number</code> parameters, <code>n</code> and <code>d</code>, and returns a <code>Number</code>.</p>
<h3 id="Index-Expressions"><a href="#Index-Expressions">Index Expressions</a></h3><p>An index expression uses <code>[]</code> to access elements from an array. Array indices start at <code>0</code> for the first element:</p>
<pre><code>let fuzz = [1, 2, 3, 4]
print fuzz[2] # =&gt; 2
</code></pre>
<h3 id="Call-Expression"><a href="#Call-Expression">Call Expression</a></h3><p>Functions and function-like types can be invoked with a call expression. A call expression begins with a left-hand side which references an invokeable, such as a function's identifier. This is followed by the parameters to the function enclosed in parenthesis <code>()</code>:</p>
<pre><code>fn add(n: Number, m: Number): Number
    n + m
end

print add(add(1, 2), 3) # =&gt; 6
</code></pre>
<footer></footer></body></html>